---
id: validating-fields
title: Validating fields
---

import CodeBlock from "@theme/CodeBlock";

`formo` supports validation of fields using `Validator`s.

```ts
export type Validator<I, O, E> = (
  input: I
) => Promise<Result<NonEmptyArray<E>, O>>;
```

A `Validator` is a function that takes the field's value as input `I` and returns a `Result` of
either errors `NonEmptyArray<E>` or a valid output `O`.

- `I = O`: If the input type corresponds to the output type, the `Validator` simply validates.
- `I â‰  O`: If they differ, the `Vaidator` may [trasform the field's value](#transforming-values).

## Simple Validation

`formo` provides a number of `Validator`s for common use cases via a `validators` utility.
Below here an example to make sue the `name` field is at least 2 characters long:

import SimpleValidation from "!!raw-loader!../examples/src/validating-fields/simple-validation/MyForm";

<CodeBlock className="language-tsx">{SimpleValidation}</CodeBlock>

Possible validation errors can be accessed via the `issues` field:

```ts
fieldProps("name").issues; // NonEmptyArray<string> | undefined
```

:::tip

The type of `issues` depends on the validator error type `E`.

For instance, if we were to use a validator as follows:

```ts
validators.minLength(2, { message: "Name is too short", severity: 1 });
```

then the type of `issues` would be

`NonEmptyArray<{ message: string, severity: number }> | undefined`

:::

## Multiple validations on a field

Some fields may require multiple validations. We can combine validations using the `inSequence`
and `inParallel` combinators.

As the name suggests, `inSequence` runs validations one after the other and the field's `issues`
will contain the **first** validation that failed:

```ts
validators.inSequence(
  validators.minLength(2, "Too short"),
  validators.regex(/^[A-Z]/, "Must start with an uppercase letter")
);
```

Alternatively, we can run the same validations in parallel:

```ts
validators.inParallel(
  validators.minLength(2, "Too short"),
  validators.regex(/^[A-Z]/, "Must start with an uppercase letter")
);
```

In this case, the field's `issues` will contain **all** the failed validations.

## Transforming values

If we take a look at how `Validator` is defined, we will notice that it has both
an input and an output type. While it's common that they are the same, this also
means that `Validators` can produce a value which is different than the one in
input.

:::note

This capability means that we're technically "parsing" instead of "validating"
the field values.

We sticked to "validation" to preserve familiarity with the term in the context
of forms.

[Here's an excellent blog post that explains the difference between parsing and
validating](https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/).

:::

One example of validation that transforms the value is the `validators.defined`
validator:

import TransformingValues from "!!raw-loader!../examples/src/validating-fields/transforming-values/MyForm";

<CodeBlock className="language-tsx">{TransformingValues}</CodeBlock>

As we discussed, `onSubmit` is only ever called **after** all field validations
succeed, and this is reflected in the types.

In this example `profession` has type `string`, while the non-validated field is
`string | undefined`.

This is a very powerful capability, because it allows you to preserve in the
types some useful information you checked during validation.

## Defining custom validations

`formo` comes with a set of common validators, but you can of course augment
them by providing your own.

For instance:

import CustomValidations from "!!raw-loader!../examples/src/validating-fields/defining-custom-validations/MyForm";

<CodeBlock className="language-tsx">{CustomValidations}</CodeBlock>
